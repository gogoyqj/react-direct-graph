{"version":3,"file":"index.js","sources":["../node_modules/tslib/tslib.es6.js","../src/core/node.interface.ts","../src/core/traverse-queue.class.ts","../src/core/matrix.class.ts","../src/core/graph.class.ts","../src/utils/index.ts","../src/components/node-icon-default.tsx","../src/components/with-foreign-object.tsx","../src/components/element.tsx","../src/components/graph.tsx","../src/index.tsx"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","/**\n * Types of nodes for internal usage\n */\nexport enum NodeType {\n    RootSimple = \"ROOT-SIMPLE\",\n    RootSplit = \"ROOT-SPLIT\",\n    Simple = \"SIMPLE\",\n    Split = \"SPLIT\",\n    Join = \"JOIN\"\n}\n/**\n * Types of anchors.\n * Join is anchor (vertex) between node and its join outcome:\n * N-J\n * N_|\n * N_|\n * Split is anchor (vertex) between node and its split income:\n * S-N\n * |_N\n * |_N\n */\nexport enum AnchorType {\n    Join = \"JOIN\",\n    Split = \"SPLIT\"\n}\n\nexport interface INodeInput<T> {\n    /**\n     * Unique key for node. Duplicates are not allowed.\n     */\n    id: string;\n    /**\n     * Outcomes of current node. Empty array if node is leaf.\n     */\n    next: string[];\n    /**\n     * Payload data to transfer with current node events. Use whatever you want here.\n     */\n    payload: T;\n}\n\nexport interface INodeOutput<T> extends INodeInput<T> {\n    /**\n     * Defines whether or not node is pseudo-node - anchor.\n     * Which is used to draw split and join edges.\n     * @default false\n     */\n    isAnchor?: boolean;\n    /**\n     * Type of anchor. Only exists if isAnchor is true.\n     */\n    anchorType?: AnchorType;\n    /**\n     * Id if the anchor income. Only exists if isAnchor is true.\n     */\n    anchorFrom?: string;\n    /**\n     * Id if the anchor outcome. Only exists if isAnchor is true.\n     */\n    anchorTo?: string;\n    /**\n     * First level node incomes passed during travesal. Ignores join\n     * anchor. Mostly for tech usage. To recognize rendering parents\n     * Use renderIncomes.\n     */\n    passedIncomes: string[];\n    /**\n     * First level node incomes in rendering context. Can be used for\n     * backward travesal. Includes both types of anchors.\n     */\n    renderIncomes: string[];\n}\n\nexport interface IMatrixNode<T> extends INodeOutput<T> {\n    /**\n     * X coordinate of node\n     */\n    x: number;\n    /**\n     * Y coordinate of node\n     */\n    y: number;\n}\n","import { INodeOutput } from \"./node.interface\";\n\nexport interface IQueueItem<T> {\n    id: string;\n    payload: T;\n    next: string[];\n}\n\n/**\n * @class TraverseQueue\n * Special queue that is used for horizontal\n * graph traversing\n */\nexport class TraverseQueue<T> {\n    private _: INodeOutput<T>[] = [];\n    /**\n     * Add items to queue. If items already exist in this queue\n     * or bufferQueue do nothing but push new passed income to\n     * existing queue item\n     * @param incomeId income id for each element\n     * @param bufferQueue buffer queue to also check for dulicates\n     * @param items queue items to add\n     */\n    add(\n        incomeId: string | null,\n        bufferQueue: TraverseQueue<T> | null,\n        ...items: IQueueItem<T>[]\n    ) {\n        items.forEach(itm => {\n            const item =\n                this.find(item => item.id === itm.id) ||\n                (bufferQueue\n                    ? bufferQueue.find(item => item.id === itm.id)\n                    : null);\n            if (item && incomeId) {\n                item.passedIncomes.push(incomeId);\n                return;\n            }\n            this._.push({\n                id: itm.id,\n                next: itm.next,\n                payload: itm.payload,\n                passedIncomes: incomeId ? [incomeId] : [],\n                renderIncomes: incomeId ? [incomeId] : []\n            });\n        });\n    }\n\n    find(cb: (item: INodeOutput<T>) => boolean): INodeOutput<T> | void {\n        return this._.find(cb);\n    }\n    /**\n     * Push item to queue. Skipping `add` method additional phases.\n     * @param item node item to add\n     */\n    push(item: INodeOutput<T>): void {\n        this._.push(item);\n    }\n    /**\n     * get current queue length\n     */\n    get length(): number {\n        return this._.length;\n    }\n    /**\n     * @param cb callback with condition to check\n     * @returns true if at list one item satified condition in callback\n     */\n    some(cb: (item: INodeOutput<T>) => boolean): boolean {\n        return this._.some(cb);\n    }\n    /**\n     * Shift first element\n     * @returns first element from the queue\n     */\n    shift(): INodeOutput<T> | void {\n        return this._.shift();\n    }\n    /**\n     * Create new queue and extract of current\n     * elements of this queue new clone\n     * @returns newQueue new queue with items from old queue\n     */\n    drain(): TraverseQueue<T> {\n        const newQueue = new TraverseQueue<T>();\n        newQueue._ = newQueue._.concat(this._);\n        this._ = [];\n        return newQueue;\n    }\n}\n","import { INodeOutput, IMatrixNode } from \"./node.interface\";\n\n/**\n * @class Matrix\n * Low level class used to compute 2D polar coordinates for each node\n * and anchor. Use this class if you want to skip D3 rendering in favor of\n * something else, for example, HTML or Canvas drawing.\n */\nexport class Matrix<T> {\n    private _: Array<Array<INodeOutput<T> | null>> = [];\n\n    /**\n     * Get with of matrix\n     */\n    get width(): number {\n        return (\n            this._.reduce(\n                (length, row) => (row.length > length ? row.length : length),\n                0\n            ) || 0\n        );\n    }\n    /**\n     * Get height of matrix\n     */\n    get height(): number {\n        return this._.length;\n    }\n    /**\n     * Checks whether or not candidate point collides\n     * with present points by X vertex.\n     * @param point coordinates of point to check\n     */\n    hasHorizontalCollision([_, y]: number[]): boolean {\n        const row = this._[y];\n        if (!row) return false;\n        return row.some((point: INodeOutput<T> | null) => !!point);\n    }\n\n    /**\n     * Checks whether or not candidate point collides\n     * with present points by Y vertex.\n     * @param point coordinates of point to check\n     */\n    hasVerticalCollision([x, y]: number[]): boolean {\n        if (x >= this.width) {\n            return false;\n        }\n        return this._.some((row, index) => {\n            if (index < y) {\n                return false;\n            }\n            return !!row[x];\n        });\n    }\n\n    /**\n     * Inspects matrix by Y vertex from top to bottom to\n     * search first unused Y coordinate (row).\n     * If there no free row on the matrix it returns\n     * matrix height (Which is equal to first unused row,\n     * that currently not exist).\n     * @param x column coordinate to use for search\n     */\n    getFreeRowForColumn(x: number): number {\n        if (this.height === 0) return 0;\n        let y = this._.findIndex(row => {\n            return !row[x];\n        });\n        if (y === -1) {\n            y = this.height;\n        }\n        return y;\n    }\n    /**\n     * Extend matrix with empty rows\n     * @param toValue rows to add to matrix\n     */\n    private _extendHeight(toValue: number): void {\n        while (this.height < toValue) {\n            const row: Array<INodeOutput<T> | null> = [];\n            row.length = this.width;\n            row.fill(null);\n            this._.push(row);\n        }\n    }\n    /**\n     * Extend matrix with empty columns\n     * @param toValue columns to add to matrix\n     */\n    private _extendWidth(toValue: number): void {\n        this._.forEach(row => {\n            while (row.length < toValue) {\n                row.push(null);\n            }\n        });\n    }\n    /**\n     * Insert row before y\n     * @param y coordinate\n     */\n    insertRowBefore(y: number) {\n        const row: Array<INodeOutput<T> | null> = [];\n        row.length = this.width;\n        row.fill(null);\n        this._.splice(y, 0, row);\n    }\n    /**\n     * Insert column before x\n     * @param x coordinate\n     */\n    insertColumnBefore(x: number) {\n        this._.forEach(row => {\n            row.splice(x, 0, null);\n        });\n    }\n    /**\n     * Find x, y coordinate of first point item that\n     * satisfies condition defined in callback\n     * @param callback similar to [].find. Returns boolean\n     */\n    find(callback: (item: INodeOutput<T>) => boolean): number[] | null {\n        let result = null;\n        this._.forEach((row, y) => {\n            row.some((point, x) => {\n                if (!point) return false;\n                if (callback(point)) {\n                    result = [x, y];\n                    return true;\n                }\n                return false;\n            });\n        });\n        return result;\n    }\n    /**\n     * Paste item to particular cell\n     * @param coords x and y coordinates for item\n     * @param item item to insert\n     */\n    insert([x, y]: number[], item: INodeOutput<T>) {\n        if (this.height <= y) {\n            this._extendHeight(y + 1);\n        }\n        if (this.width <= x) {\n            this._extendWidth(x + 1);\n        }\n\n        this._[y][x] = item;\n    }\n    /**\n     * @returns key value object where key is node id and\n     * value is node with its coordinates\n     */\n    normalize(): { [id: string]: IMatrixNode<T> } {\n        return this._.reduce((acc, row, y) => {\n            row.forEach((item, x) => {\n                if (!item) return;\n                acc[item.id] = { ...item, x, y };\n            });\n            return acc;\n        }, {});\n    }\n}\n","import {\n    INodeInput,\n    NodeType,\n    AnchorType,\n    INodeOutput\n} from \"./node.interface\";\nimport { TraverseQueue } from \"./traverse-queue.class\";\nimport { Matrix } from \"./matrix.class\";\n\nconst MAX_ITERATIONS = 10000;\n\n/**\n * Holds iteration state of the graph\n */\ninterface State<T> {\n    mtx: Matrix<T>;\n    queue: TraverseQueue<T>;\n    x: number;\n    y: number;\n}\n\n/**\n * @class Graph\n * Main compute class used to transform\n * linked list of nodes to coordinate matrix\n */\nexport class Graph<T> {\n    private _list: INodeInput<T>[] = [];\n    private _nodesMap: { [id: string]: INodeInput<T> } = {};\n    private _incomesByNodeIdMap: { [id: string]: string[] } = {};\n    private _outcomesByNodeIdMap: { [id: string]: string[] } = {};\n    constructor(list: INodeInput<T>[]) {\n        this.applyList(list);\n    }\n    /**\n     * Fill graph with new nodes\n     * @param list input linked list of nodes\n     */\n    applyList(list: INodeInput<T>[]): void {\n        this._incomesByNodeIdMap = {};\n        this._outcomesByNodeIdMap = {};\n        this._nodesMap = {};\n        this._list = list;\n        list.forEach(node => {\n            if (this._nodesMap[node.id]) {\n                throw new Error(`Duplicate node id ${node.id}`);\n            }\n            this._nodesMap[node.id] = node;\n            node.next.forEach(outcomeId => {\n                this._incomesByNodeIdMap[outcomeId] = this._incomesByNodeIdMap[\n                    outcomeId\n                ]\n                    ? [...this._incomesByNodeIdMap[outcomeId], node.id]\n                    : [node.id];\n                const incomes = this._incomesByNodeIdMap[outcomeId];\n                if (new Set(incomes).size !== incomes.length) {\n                    throw new Error(`Duplicate incomes for node id ${node.id}`);\n                }\n            });\n            this._outcomesByNodeIdMap[node.id] = [...node.next];\n            const outcomes = this._outcomesByNodeIdMap[node.id];\n            if (new Set(outcomes).size !== outcomes.length) {\n                throw new Error(`Duplicate outcomes for node id ${node.id}`);\n            }\n        });\n    }\n    /**\n     * Get graph roots.\n     * Roots is nodes without incomes\n     */\n    roots(): INodeInput<T>[] {\n        return this._list.filter(node => this.isRoot(node.id));\n    }\n    /**\n     * Get type of node\n     * @param id id of node\n     * @returns type of the node\n     */\n    private nodeType(id: string): NodeType {\n        if (this.isRoot(id) && this.isSplit(id)) return NodeType.RootSplit;\n        if (this.isRoot(id)) return NodeType.RootSimple;\n        if (this.isSplit(id)) return NodeType.Split;\n        if (this.isJoin(id)) return NodeType.Join;\n        return NodeType.Simple;\n    }\n    /**\n     * Whether or node is split\n     * @param id id of node\n     */\n    private isSplit(id: string): boolean {\n        return (\n            this._outcomesByNodeIdMap[id] &&\n            this._outcomesByNodeIdMap[id].length > 1\n        );\n    }\n    /**\n     * Whether or node is join\n     * @param id id of node\n     */\n    private isJoin(id: string): boolean {\n        return (\n            this._incomesByNodeIdMap[id] &&\n            this._incomesByNodeIdMap[id].length > 1\n        );\n    }\n    /**\n     * Whether or node is root\n     * @param id id of node\n     */\n    private isRoot(id: string): boolean {\n        return (\n            !this._incomesByNodeIdMap[id] ||\n            !this._incomesByNodeIdMap[id].length\n        );\n    }\n    /**\n     * Get outcomes of node by id\n     * @param id id of node\n     */\n    private outcomes(id: string): string[] {\n        return this._outcomesByNodeIdMap[id];\n    }\n    /**\n     * Get incomes of node by id\n     * @param id id of node\n     */\n    private incomes(id: string): string[] {\n        return this._incomesByNodeIdMap[id];\n    }\n    /**\n     * Get node by id\n     * @param id node id\n     */\n    private node(id: string): INodeInput<T> {\n        return this._nodesMap[id];\n    }\n    /**\n     * Check if item has unresolved incomes\n     * @param item item to check\n     */\n    private _joinHasUnresolvedIncomes(item: INodeOutput<T>) {\n        return item.passedIncomes.length != this.incomes(item.id).length;\n    }\n    /**\n     * Main insertion method - inserts item on matrix using state x and y\n     * or skips if it has collision on current row. Skipping is done\n     * by passing item back to the end of the queue\n     * @param item item to insert\n     * @param state state of current iteration\n     * @param checkCollision whether to check horizontal collision with existing point\n     * on 2D matrix\n     * @returns true if item was inserted false if skipped\n     */\n    private _insertOrSkipNodeOnMatrix(\n        item: INodeOutput<T>,\n        state: State<T>,\n        checkCollision: boolean\n    ): boolean {\n        const { mtx } = state;\n        // if point collides by x vertex, insert new row before y position\n        if (checkCollision && mtx.hasHorizontalCollision([state.x, state.y])) {\n            mtx.insertRowBefore(state.y);\n        }\n        mtx.insert([state.x, state.y], item);\n        return true;\n    }\n    /**\n     * Get all items incomes and find parent Y with the lowest\n     * Y coordinate on the matrix\n     * @param item target item\n     * @param mtx matrix to use as source\n     */\n    private _getLowestYAmongIncomes(\n        item: INodeOutput<T>,\n        mtx: Matrix<T>\n    ): number {\n        const incomes = item.passedIncomes;\n        if (incomes && incomes.length) {\n            // get lowest income y\n            const items = incomes.map(id => {\n                const coords = mtx.find(item => item.id === id);\n                if (!coords) {\n                    throw new Error(\n                        `Cannot find coordinates for passed income: \"${id}\"`\n                    );\n                }\n                return coords[1];\n            });\n            const y = Math.min(...items);\n            return y;\n        }\n        return 0;\n    }\n\n    /**\n     * Main processing nodes method.\n     * If node has incomes it finds lowest Y among them and\n     * sets state.y as lowest income Y value.\n     * Then inserts item on matrix using state x and y\n     * or skips if it has collision on current column. Skipping is done\n     * by passing item back to the end of the queue\n     * @param item item to insert\n     * @param state state of current iteration\n     * on 2D matrix\n     * @returns true if item was inserted false if skipped\n     */\n    private _processOrSkipNodeOnMatrix(item: INodeOutput<T>, state: State<T>) {\n        const { mtx, queue } = state;\n        if (item.passedIncomes && item.passedIncomes.length) {\n            state.y = this._getLowestYAmongIncomes(item, mtx);\n        }\n        // if point collides by y vertex, skipp it to next x\n        if (mtx.hasVerticalCollision([state.x, state.y])) {\n            queue.push(item);\n            return false;\n        }\n        return this._insertOrSkipNodeOnMatrix(item, state, false);\n    }\n    /**\n     * traverse main method to get coordinates matrix from graph\n     * @returns 2D matrix containing all nodes and anchors\n     */\n    traverse() {\n        const roots = this.roots();\n        const state: State<T> = {\n            mtx: new Matrix<T>(),\n            queue: new TraverseQueue(),\n            x: 0,\n            y: 0\n        };\n        let _safe = 0;\n        const { mtx, queue } = state;\n        queue.add(\n            null,\n            null,\n            ...roots.map(r => ({ id: r.id, payload: r.payload, next: r.next }))\n        );\n        let isInserted = false;\n        while (queue.length) {\n            const levelQueue = queue.drain();\n            while (levelQueue.length) {\n                _safe++;\n                const item = levelQueue.shift();\n                if (!item) throw new Error(\"Cannot shift from buffer queue\");\n                switch (this.nodeType(item.id)) {\n                    case NodeType.RootSimple:\n                        state.y = mtx.getFreeRowForColumn(0);\n                    case NodeType.Simple:\n                        isInserted = this._processOrSkipNodeOnMatrix(\n                            item,\n                            state\n                        );\n                        if (isInserted) {\n                            queue.add(\n                                item.id,\n                                levelQueue,\n                                ...this.outcomes(item.id).map(outcomeId => {\n                                    const out = this.node(outcomeId);\n                                    return {\n                                        id: out.id,\n                                        next: out.next,\n                                        payload: out.payload\n                                    };\n                                })\n                            );\n                        }\n                        break;\n                    case NodeType.RootSplit:\n                        state.y = mtx.getFreeRowForColumn(0);\n                    case NodeType.Split:\n                        isInserted = this._processOrSkipNodeOnMatrix(\n                            item,\n                            state\n                        );\n                        if (isInserted) {\n                            const outcomes = this.outcomes(item.id);\n                            // first will be on the same y level as parent split\n                            const firstOutcomeId = outcomes.shift();\n                            if (!firstOutcomeId)\n                                throw new Error(\n                                    `Split \"${item.id}\" has no outcomes`\n                                );\n                            const first = this.node(firstOutcomeId);\n                            queue.add(item.id, levelQueue, {\n                                id: first.id,\n                                next: first.next,\n                                payload: first.payload\n                            });\n                            // rest will create anchor with shift down by one\n                            outcomes.forEach(outcomeId => {\n                                state.y++;\n                                const id = `${item.id}-${outcomeId}`;\n\n                                this._insertOrSkipNodeOnMatrix(\n                                    {\n                                        id: id,\n                                        anchorType: AnchorType.Split,\n                                        anchorFrom: item.id,\n                                        anchorTo: outcomeId,\n                                        isAnchor: true,\n                                        renderIncomes: [item.id],\n                                        passedIncomes: [item.id],\n                                        payload: item.payload,\n                                        next: [outcomeId]\n                                    },\n                                    state,\n                                    true\n                                );\n                                const out = this.node(outcomeId);\n                                queue.add(id, levelQueue, {\n                                    id: out.id,\n                                    next: out.next,\n                                    payload: out.payload\n                                });\n                            });\n                        }\n                        break;\n                    case NodeType.Join:\n                        if (this._joinHasUnresolvedIncomes(item)) {\n                            queue.push(item);\n                        } else {\n                            isInserted = this._processOrSkipNodeOnMatrix(\n                                item,\n                                state\n                            );\n                            item.renderIncomes = [];\n                            if (isInserted) {\n                                const incomes = item.passedIncomes;\n                                const lowestY = this._getLowestYAmongIncomes(\n                                    item,\n                                    mtx\n                                );\n                                incomes.forEach(incomeId => {\n                                    const point = mtx.find(\n                                        item => item.id === incomeId\n                                    );\n                                    if (!point)\n                                        throw new Error(\n                                            `Income ${incomeId} not found on matrix`\n                                        );\n                                    const [, y] = point;\n                                    if (lowestY === y) {\n                                        item.renderIncomes.push(incomeId);\n                                        return;\n                                    }\n                                    state.y = y;\n                                    const id = `${incomeId}-${item.id}`;\n                                    item.renderIncomes.push(id);\n                                    this._insertOrSkipNodeOnMatrix(\n                                        {\n                                            id: id,\n                                            anchorType: AnchorType.Join,\n                                            anchorFrom: incomeId,\n                                            anchorTo: item.id,\n                                            isAnchor: true,\n                                            renderIncomes: [incomeId],\n                                            passedIncomes: [incomeId],\n                                            payload: item.payload,\n                                            next: [item.id]\n                                        },\n                                        state,\n                                        false\n                                    );\n                                });\n                                queue.add(\n                                    item.id,\n                                    levelQueue,\n                                    ...this.outcomes(item.id).map(outcomeId => {\n                                        const out = this.node(outcomeId);\n                                        return {\n                                            id: out.id,\n                                            next: out.next,\n                                            payload: out.payload\n                                        };\n                                    })\n                                );\n                            }\n                        }\n                        break;\n                }\n                if (_safe > MAX_ITERATIONS) {\n                    throw new Error(`Infinite loop`);\n                    return mtx;\n                }\n            }\n            state.x++;\n        }\n        return mtx;\n    }\n}\n","export enum VectorDirection {\n    Top = \"top\",\n    Bottom = \"bottom\",\n    Right = \"right\",\n    Left = \"left\"\n}\n\nexport const getVectorDirection = (\n    x1: number,\n    y1: number,\n    x2: number,\n    y2: number\n): VectorDirection => {\n    if (y1 === y2) {\n        if (x1 < x2) return VectorDirection.Right;\n        else return VectorDirection.Left;\n    } else {\n        if (y1 < y2) return VectorDirection.Bottom;\n        else return VectorDirection.Top;\n    }\n};\n\nexport const getCellCenter = (\n    sellSize: number,\n    cellX: number,\n    cellY: number\n): number[] => {\n    const x = cellX * sellSize + sellSize * 0.5;\n    const y = cellY * sellSize + sellSize * 0.5;\n    return [x, y];\n};\n\nexport const getCellTopEntry = (\n    sellSize: number,\n    padding: number,\n    cellX: number,\n    cellY: number\n): number[] => {\n    const [x] = getCellCenter(sellSize, cellX, cellY);\n    const y = cellY * sellSize + padding;\n    return [x, y];\n};\n\nexport const getCellBottomEntry = (\n    sellSize: number,\n    padding: number,\n    cellX: number,\n    cellY: number\n): number[] => {\n    const [x] = getCellCenter(sellSize, cellX, cellY);\n    const y = cellY * sellSize + (sellSize - padding);\n    return [x, y];\n};\n\nexport const getCellRightEntry = (\n    sellSize: number,\n    padding: number,\n    cellX: number,\n    cellY: number\n): number[] => {\n    const [, y] = getCellCenter(sellSize, cellX, cellY);\n    const x = cellX * sellSize + (sellSize - padding);\n    return [x, y];\n};\n\nexport const getCellLeftEntry = (\n    sellSize: number,\n    padding: number,\n    cellX: number,\n    cellY: number\n): number[] => {\n    const [, y] = getCellCenter(sellSize, cellX, cellY);\n    const x = cellX * sellSize + padding;\n    return [x, y];\n};\n","import { GraphNodeIconComponentProps } from \"./node-icon\";\nimport { INodeInput } from \"../core\";\nimport * as React from \"react\";\n\nexport class DefaultNodeIcon<T> extends React.Component<\n    GraphNodeIconComponentProps<T>\n> {\n    getColor(node: INodeInput<T>, incomes: INodeInput<T>[]): string {\n        if (incomes && incomes.length > 1) return \"#e25300\";\n        if (node.next && node.next.length > 1) return \"#008c15\";\n        return \"#193772\";\n    }\n    render() {\n        const { node, incomes } = this.props;\n        return (\n            <svg version=\"1.1\" x=\"0px\" y=\"0px\" viewBox=\"0 0 52 52\">\n                <g>\n                    <path\n                        style={{\n                            fill: this.getColor(node, incomes),\n                            stroke: this.getColor(node, incomes)\n                        }}\n                        d=\"M40.824,52H11.176C5.003,52,0,46.997,0,40.824V11.176C0,5.003,5.003,0,11.176,0h29.649   C46.997,0,52,5.003,52,11.176v29.649C52,46.997,46.997,52,40.824,52z\"\n                    />\n                    <g fill=\"#ffffff\" stroke=\"#ffffff\">\n                        <text\n                            strokeWidth=\"1\"\n                            x=\"0\"\n                            y=\"0\"\n                            dx=\"26\"\n                            dy=\"30\"\n                            textAnchor=\"middle\"\n                            fontSize=\"14px\"\n                        >\n                            {node.id}\n                        </text>\n                    </g>\n                </g>\n            </svg>\n        );\n    }\n}\n","import * as React from \"react\";\n\ninterface WithForeignObjectProps {\n    width: number;\n    height: number;\n    x: number;\n    y: number;\n}\n\nexport const withForeignObject = <P extends Object>(\n    WrappedSVGComponent: React.ComponentType<P>\n): React.FC<P & WithForeignObjectProps> => ({\n    width,\n    height,\n    x,\n    y,\n    ...props\n}: WithForeignObjectProps) => (\n    <foreignObject\n        x={x}\n        y={y}\n        width={width}\n        height={height}\n        className={\"node-icon\"}\n    >\n        <WrappedSVGComponent {...props as P} />\n    </foreignObject>\n);\n","import * as React from \"react\";\nimport { IMatrixNode } from \"../core\";\nimport {\n    VectorDirection,\n    getVectorDirection,\n    getCellCenter,\n    getCellTopEntry,\n    getCellBottomEntry,\n    getCellRightEntry,\n    getCellLeftEntry\n} from \"../utils\";\nimport { GraphNodeIconComponentProps } from \"./node-icon\";\nimport { DefaultNodeIcon } from \"./node-icon-default\";\nimport { withForeignObject } from \"./with-foreign-object\";\n\nexport type GraphEventFunc<T> = (\n    event: React.MouseEvent,\n    node: IMatrixNode<T>,\n    incomes: IMatrixNode<T>[]\n) => void;\n\nexport type ViewProps<T> = {\n    component?: React.ComponentType<GraphNodeIconComponentProps<T>>;\n    onNodeMouseEnter?: GraphEventFunc<T>;\n    onNodeMouseLeave?: GraphEventFunc<T>;\n    onEdgeMouseEnter?: GraphEventFunc<T>;\n    onEdgeMouseLeave?: GraphEventFunc<T>;\n    onNodeClick?: GraphEventFunc<T>;\n    onEdgeClick?: GraphEventFunc<T>;\n    sellSize: number;\n    padding: number;\n};\n\nexport type DataProps<T> = {\n    node: IMatrixNode<T>;\n    incomes: IMatrixNode<T>[];\n};\n\nexport class GraphElement<T> extends React.Component<\n    DataProps<T> & ViewProps<T>\n> {\n    getLineToIncome(\n        sellSize: number,\n        padding: number,\n        node: IMatrixNode<T>,\n        income: IMatrixNode<T>\n    ) {\n        const direction = getVectorDirection(\n            node.x,\n            node.y,\n            income.x,\n            income.y\n        );\n        let x1, y1, x2, y2;\n\n        switch (direction) {\n            case VectorDirection.Top:\n                if (node.isAnchor) {\n                    [x1, y1] = getCellCenter(sellSize, node.x, node.y);\n                } else {\n                    [x1, y1] = getCellTopEntry(\n                        sellSize,\n                        padding,\n                        node.x,\n                        node.y\n                    );\n                }\n                if (income.isAnchor) {\n                    [x2, y2] = getCellCenter(sellSize, income.x, income.y);\n                } else {\n                    [x2, y2] = getCellBottomEntry(\n                        sellSize,\n                        padding,\n                        income.x,\n                        income.y\n                    );\n                }\n                break;\n            case VectorDirection.Bottom:\n                if (node.isAnchor) {\n                    [x1, y1] = getCellCenter(sellSize, node.x, node.y);\n                } else {\n                    [x1, y1] = getCellBottomEntry(\n                        sellSize,\n                        padding,\n                        node.x,\n                        node.y\n                    );\n                }\n                if (income.isAnchor) {\n                    [x2, y2] = getCellCenter(sellSize, income.x, income.y);\n                } else {\n                    [x2, y2] = getCellTopEntry(\n                        sellSize,\n                        padding,\n                        income.x,\n                        income.y\n                    );\n                }\n                break;\n            case VectorDirection.Right:\n                if (node.isAnchor) {\n                    [x1, y1] = getCellCenter(sellSize, node.x, node.y);\n                } else {\n                    [x1, y1] = getCellRightEntry(\n                        sellSize,\n                        padding,\n                        node.x,\n                        node.y\n                    );\n                }\n                if (income.isAnchor) {\n                    [x2, y2] = getCellCenter(sellSize, income.x, income.y);\n                } else {\n                    [x2, y2] = getCellLeftEntry(\n                        sellSize,\n                        padding,\n                        income.x,\n                        income.y\n                    );\n                }\n                break;\n            case VectorDirection.Left:\n                if (node.isAnchor) {\n                    [x1, y1] = getCellCenter(sellSize, node.x, node.y);\n                } else {\n                    [x1, y1] = getCellLeftEntry(\n                        sellSize,\n                        padding,\n                        node.x,\n                        node.y\n                    );\n                }\n                if (income.isAnchor) {\n                    [x2, y2] = getCellCenter(sellSize, income.x, income.y);\n                } else {\n                    [x2, y2] = getCellRightEntry(\n                        sellSize,\n                        padding,\n                        income.x,\n                        income.y\n                    );\n                }\n                break;\n        }\n        return {\n            node,\n            income,\n            line: [x1, y1, x2, y2]\n        };\n    }\n\n    getLines(\n        sellSize: number,\n        padding: number,\n        node: IMatrixNode<T>,\n        incomes: IMatrixNode<T>[]\n    ) {\n        return node.isAnchor\n            ? incomes.map(income =>\n                  this.getLineToIncome(sellSize, padding, income, node)\n              )\n            : incomes.map(income =>\n                  this.getLineToIncome(sellSize, padding, node, income)\n              );\n    }\n\n    getCoords(\n        sellSize: number,\n        padding: number,\n        node: IMatrixNode<T>\n    ): number[] {\n        return [node.x * sellSize + padding, node.y * sellSize + padding];\n    }\n\n    getSize(sellSize: number, padding: number): number {\n        return sellSize - padding * 2;\n    }\n\n    wrapEventHandler = (\n        cb: GraphEventFunc<T>,\n        node: IMatrixNode<T>,\n        incomes: IMatrixNode<T>[]\n    ): ((e: React.MouseEvent) => void) => {\n        return (e: React.MouseEvent) => cb(e, node, incomes);\n    };\n\n    render() {\n        const {\n            node,\n            incomes,\n            sellSize,\n            padding,\n            onNodeClick,\n            onNodeMouseEnter,\n            onNodeMouseLeave,\n            onEdgeClick,\n            onEdgeMouseEnter,\n            onEdgeMouseLeave\n        } = this.props;\n        const [x, y] = this.getCoords(sellSize, padding, node);\n        const lines = this.getLines(sellSize, padding, node, incomes);\n        const size = this.getSize(sellSize, padding);\n        const NodeIcon = withForeignObject<GraphNodeIconComponentProps<T>>(\n            this.props.component ? this.props.component : DefaultNodeIcon\n        );\n\n        return (\n            <g\n                className=\"node-group\"\n                style={{\n                    strokeWidth: 2,\n                    fill: \"#ffffff\",\n                    stroke: \"#2d578b\"\n                }}\n            >\n                {!node.isAnchor && (\n                    <g\n                        className=\"node-icon-group\"\n                        {...{\n                            onClick:\n                                onNodeClick &&\n                                this.wrapEventHandler(\n                                    onNodeClick,\n                                    node,\n                                    incomes\n                                ),\n                            onMouseEnter:\n                                onNodeMouseEnter &&\n                                this.wrapEventHandler(\n                                    onNodeMouseEnter,\n                                    node,\n                                    incomes\n                                ),\n                            onMouseLeave:\n                                onNodeMouseLeave &&\n                                this.wrapEventHandler(\n                                    onNodeMouseLeave,\n                                    node,\n                                    incomes\n                                )\n                        }}\n                    >\n                        <NodeIcon\n                            x={x}\n                            y={y}\n                            height={size}\n                            width={size}\n                            node={node}\n                            incomes={incomes}\n                        />\n                    </g>\n                )}\n                {lines.map((l) => (\n                    <line\n                        {...{\n                            onClick:\n                                onEdgeClick &&\n                                this.wrapEventHandler(onEdgeClick, l.node, [\n                                    l.income\n                                ]),\n                            onMouseEnter:\n                                onEdgeMouseEnter &&\n                                this.wrapEventHandler(\n                                    onEdgeMouseEnter,\n                                    l.node,\n                                    [l.income]\n                                ),\n                            onMouseLeave:\n                                onEdgeMouseLeave &&\n                                this.wrapEventHandler(\n                                    onEdgeMouseLeave,\n                                    l.node,\n                                    [l.income]\n                                )\n                        }}\n                        key={`line-${node.id}-${l.income.id}`}\n                        className=\"node-line\"\n                        x1={l.line[0]}\n                        y1={l.line[1]}\n                        x2={l.line[2]}\n                        y2={l.line[3]}\n                    />\n                ))}\n            </g>\n        );\n    }\n}\n","import * as React from \"react\";\nimport { IMatrixNode } from \"../core\";\nimport { GraphElement, ViewProps } from \"./element\";\n\nexport type Props<T> = {\n    nodesMap: { [id: string]: IMatrixNode<T> };\n    sellSize: number;\n    padding: number;\n    widthInCells: number;\n    heightInCells: number;\n};\n\ninterface INodeElementInput<T> {\n    node: IMatrixNode<T>;\n    incomes: IMatrixNode<T>[];\n}\n\nexport class Graph<T> extends React.Component<Props<T> & ViewProps<T>> {\n    getNodeElementInputs = (nodesMap: {\n        [id: string]: IMatrixNode<T>;\n    }): INodeElementInput<T>[] => {\n        return Object.entries(nodesMap).map(([_, node]) => ({\n            node,\n            incomes: node.renderIncomes.map(id => nodesMap[id])\n        }));\n    };\n    render() {\n        const {\n            nodesMap,\n            sellSize,\n            padding,\n            widthInCells,\n            heightInCells,\n            ...restProps\n        } = this.props;\n        const elements = this.getNodeElementInputs(nodesMap);\n\n        return (\n            <svg\n                version=\"1\"\n                width={widthInCells * sellSize}\n                height={heightInCells * sellSize}\n            >\n                {elements.map(props => (\n                    <GraphElement\n                        key={props.node.id}\n                        sellSize={sellSize}\n                        padding={padding}\n                        {...props}\n                        {...restProps}\n                    />\n                ))}\n            </svg>\n        );\n    }\n}\n","/**\n * @class DirectGraph\n */\n\nimport * as React from \"react\";\nimport { INodeInput, IMatrixNode, Graph } from \"./core\";\nimport { Graph as GraphView, ViewProps } from \"./components\";\n\nexport type Props<T> = {\n    list: INodeInput<T>[];\n    sellSize: number;\n    padding: number;\n};\n\ntype GraphViewData<T> = {\n    nodesMap: { [id: string]: IMatrixNode<T> };\n    widthInCells: number;\n    heightInCells: number;\n};\n\nexport default class DirectGraph<T> extends React.Component<\n    Props<T> & ViewProps<T>\n> {\n    getNodesMap = (list: INodeInput<T>[]): GraphViewData<T> => {\n        const graph = new Graph(list);\n        const mtx = graph.traverse();\n        return {\n            nodesMap: mtx.normalize(),\n            widthInCells: mtx.width,\n            heightInCells: mtx.height\n        };\n    };\n\n    render() {\n        const { list, ...viewProps } = this.props;\n        const dataProps = this.getNodesMap(list);\n\n        return <GraphView {...dataProps} {...viewProps} />;\n    }\n}\n"],"names":["tslib_1.__extends","React.createElement","React.Component","GraphView"],"mappings":"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"}